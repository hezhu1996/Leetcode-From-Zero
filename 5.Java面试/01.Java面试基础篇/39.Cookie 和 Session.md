# Cookie 和 Session

## 1.什么是 Cookie

* HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到**用户浏览器并保存在本地的一小块数据**，它会在浏览器下次向同一服务器**再发起请求时被携带**并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
* Cookie 主要用于以下三个方面：
  1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  2. 个性化设置（如用户自定义设置、主题等）
  3. 浏览器行为跟踪（如跟踪分析用户行为等）



## 2.什么是 Session

- Session 代表着**服务器和客户端一次会话的过程**。Session 对象**存储特定用户会话所需的属性及配置信息**。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。



## 3.Cookie 和 Session 有什么不同？

- 作用范围不同，**Cookie** 保存在**客户端**（浏览器），Session 保存在**服务器端**。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。



## 4.为什么需要 Cookie 和 Session，他们有什么关联？

* Cookie：浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。
  
* 浏览器 与 服务器 通信
  * <img src="https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210509204258414.png" alt="image-20210509204258414" style="zoom:80%;" />
  * **第一次：**用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
  * **第二次：**当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。



## 5.Token

* 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转？
  * 解决方案：Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。
  * Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。
  * 当用户第一次登录后，服务器 **根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可** ，无需再次登录验证。



## 6.跨域问题

* 浏览器的同源策略：指 **"协议+域名+端口"** 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。
* 解决跨域请求的常用方法是：
  1. 通过代理来避免，比如使用 **Nginx 在后端转发请求**，避免了前端出现跨域的问题。
  2. 通过 Jsonp 跨域
  3. 其它跨域解决方案



































